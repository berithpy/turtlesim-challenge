<!DOCTYPE html>
<html>

<head>

  <script type="text/javascript" src="http://cdn.robotwebtools.org/EventEmitter2/current/eventemitter2.min.js"></script>
  <script type="text/javascript" src="http://cdn.robotwebtools.org/roslibjs/current/roslib.js"></script>

  <script type="text/javascript" type="text/javascript">
    var rosBridgeServer = new ROSLIB.Ros({
      url: 'ws://localhost:9090'
    });
    rosBridgeServer.on('connection', function () {
      var fbDiv = document.getElementById('feedback');
      fbDiv.innerHTML += "<p>Connected to websocket server.</p>";
    });
    rosBridgeServer.on('error', function (error) {
      var fbDiv = document.getElementById('feedback');
      fbDiv.innerHTML += "<p>Error connecting to websocket server.</p>";
    });

    // This function is called when the connection to rosbridge is closed
    rosBridgeServer.on('close', function () {
      // Write appropriate message to #feedback div upon closing connection to rosbridge
      var fbDiv = document.getElementById('feedback');
      fbDiv.innerHTML += "<p>Connection to websocket server closed.</p>";
    });
    var turtlePose = {}
    var queue = []

    function addTask(queue, task, parameters) {
      queue.push(Array.prototype.slice.call(arguments, 1))
    }

    function executeNextTask(queue) {
      task = queue.pop()
      task[0].apply(cmdVelTopic, task.slice(1))
    }

    function scheduler(message) {
      turtlePose = message;
      if (!turtlePose.angular_velocity && !turtlePose.linear_velocity && queue.length) {
        executeNextTask(queue)
      }
    }

    var poseTopic = new ROSLIB.Topic({
      ros: rosBridgeServer,
      name: '/turtle1/pose',
      messageType: 'turtlesim/Pose',
    });
    poseTopic.subscribe(scheduler)
    
    var cmdVelTopic = new ROSLIB.Topic({
      ros: rosBridgeServer,
      name: '/turtle1/cmd_vel',
      messageType: 'geometry_msgs/Twist',
    });


    function newTwist() {
      return new ROSLIB.Message({
        linear: {
          x: 0.0,
          y: 0.0,
          z: 0.0
        },
        angular: {
          x: 0.0,
          y: 0.0,
          z: 0.0
        }
      });
    }


    function drawCuteStar() {
      /**
      Set the appropriate values on the twist message object according to values in text boxes
      It seems that turtlesim only uses the x property of the linear object 
      and the z property of the angular object
      **/
      var linearX = 0.0;
      var angularZ = 0.0;

      // get values from text input fields. Note for simplicity we are not validating.
      linearX = 0 + Number(document.getElementById('linearXText').value);
      angularZ = 0 + Number(document.getElementById('angularZText').value);

      // Set the appropriate values on the message object
      twist.linear.x = linearX;
      twist.angular.z = angularZ;

      // Publish the message 
      cmdVelTopic.publish(twist);
    }

    function rotate(angle) {
      twist = newTwist();
      twist.angular.z = angle * (Math.PI / 180);
      addTask(queue, cmdVelTopic.publish, twist);
      // cmdVelTopic.publish(twist)
    }

    function move(distance) {
      twist = newTwist();
      twist.linear.x = distance;
      addTask(queue, cmdVelTopic.publish, twist);
      // cmdVelTopic.publish(twist)
    }

    function drawPentagram(size, sides) {
      sides = Array(sides).fill().map((_, i) => i + 1);
      sides.forEach(function (side) {
        move(size)
        rotate(180)
        rotate(36)
      })
    }
  </script>
</head>

<body>
  <button id="sendMsg" type="button" onclick="drawPentagram(3,5);">Draw pentagram</button>
  <div id="feedback"></div>
</body>

</html>